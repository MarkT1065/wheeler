<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Monthly View - Wheeler</title>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/styles.css">
</head>
<body class="monthly-page">
    <div class="app-container">
        <!-- Sidebar -->
        {{template "_navigation.html" .}}
        
        <!-- Main Content -->
        <div class="main-content">
            
            <!-- Aggregated Totals Panel -->
            <div class="content-section" style="margin-bottom: 20px;">
                <div style="background: #2d2d2d; padding: 15px; border-radius: 8px; border: 1px solid #404040; text-align: center; font-size: 20px;">
                    <span style="color: #a0a0a0;">Total:</span> <span id="grandTotal" style="color: #27ae60;">$0</span>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                    <span style="color: #a0a0a0;">Puts:</span> <span id="totalPuts" style="color: #27ae60;">$0</span>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                    <span style="color: #a0a0a0;">Calls:</span> <span id="totalCalls" style="color: #27ae60;">$0</span>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                    <span style="color: #a0a0a0;">Capital Gains:</span> <span id="totalCapGains" style="color: #27ae60;">$0</span>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                    <span style="color: #a0a0a0;">Dividends:</span> <span id="totalDividends" style="color: #27ae60;">$0</span>
                </div>
            </div>
            
            <!-- Added by antamy                              -->
            <!-- Gains Chart with Cumulative / Monthly Toggle -->

            <div class="content-section" style="margin-bottom: 30px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <div class="section-title">Gains Over Time</div>
                    <div class="toggle-button-group" style="display: flex; gap: 5px;">
                        <button id="cumulativeToggle" class="toggle-btn active" data-view="cumulative" style="padding: 8px 16px; background-color: #27ae60; color: white; border: 1px solid #1e8449; border-radius: 4px 0 0 4px; cursor: pointer; font-weight: 600; font-size: 14px; transition: all 0.2s ease;">Cumulative</button>
                        <button id="monthlyToggle" class="toggle-btn" data-view="monthly" style="padding: 8px 16px; background-color: #34495e; color: #bdc3c7; border: 1px solid #2c3e50; border-radius: 0 4px 4px 0; cursor: pointer; font-weight: 600; font-size: 14px; transition: all 0.2s ease;">Monthly</button>
                    </div>
                </div>
                <div class="chart-container-large">
                    <canvas id="cumulativeGainsChart"></canvas>
                </div>
            </div>
            
            <!-- All Charts with Legend -->
            <div style="display: flex; gap: 20px; margin-bottom: 30px;">
                <!-- Left: All Charts (90% width) -->
                <div style="flex: 9;">
                    <div class="content-section" style="height: 100%;">
                        <div class="options-section-row" style="margin-top: 0;">
                        <!-- Puts Section -->
                        <div class="content-section">
                            <div class="section-title">Puts</div>
                            <div class="charts-row">
                                <div class="chart-column">
                                    <h4>By Month</h4>
                                    <div class="chart-container-small">
                                        <canvas id="putsMonthChart"></canvas>
                                    </div>
                                </div>
                                <div class="chart-column">
                                    <h4>By Ticker</h4>
                                    <div class="chart-container-small">
                                        <canvas id="putsTickerChart"></canvas>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Calls Section -->
                        <div class="content-section">
                            <div class="section-title">Calls</div>
                            <div class="charts-row">
                                <div class="chart-column">
                                    <h4>By Month</h4>
                                    <div class="chart-container-small">
                                        <canvas id="callsMonthChart"></canvas>
                                    </div>
                                </div>
                                <div class="chart-column">
                                    <h4>By Ticker</h4>
                                    <div class="chart-container-small">
                                        <canvas id="callsTickerChart"></canvas>
                                    </div>
                                </div>
                            </div>
                        </div>
                        </div>
                        
                        <div class="options-section-row" style="margin-top: 0;">
                        <!-- Capital Gains Section -->
                        <div class="content-section">
                            <div class="section-title">Capital Gains</div>
                            <div class="charts-row">
                                <div class="chart-column">
                                    <h4>By Month</h4>
                                    <div class="chart-container-small">
                                        <canvas id="capGainsMonthChart"></canvas>
                                    </div>
                                </div>
                                <div class="chart-column">
                                    <h4>By Ticker</h4>
                                    <div class="chart-container-small">
                                        <canvas id="capGainsTickerChart"></canvas>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Dividends Section -->
                        <div class="content-section">
                            <div class="section-title">Dividends</div>
                            <div class="charts-row">
                                <div class="chart-column">
                                    <h4>By Month</h4>
                                    <div class="chart-container-small">
                                        <canvas id="dividendsMonthChart"></canvas>
                                    </div>
                                </div>
                                <div class="chart-column">
                                    <h4>By Ticker</h4>
                                    <div class="chart-container-small">
                                        <canvas id="dividendsTickerChart"></canvas>
                                    </div>
                                </div>
                            </div>
                        </div>
                        </div>
                    </div>
                </div>
                
                <!-- Right: Symbol Legend (10% width) -->
                <div style="flex: 1;">
                    <div class="content-section" style="height: 100%;">
                        <div class="section-title">Legend</div>
                        <div id="symbolLegend" style="padding: 20px; display: flex; flex-direction: column; flex-wrap: wrap; gap: 8px; max-height: 700px; align-content: flex-start;">
                            <!-- Legend will be populated by JavaScript -->
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Monthly Premiums by Symbol Grouped by Open/Closed -->
            <div class="content-section" style="margin-bottom: 30px;">
                <div class="section-title">Monthly Premiums by Symbol (Open/Closed)</div>
                <div class="chart-container-large">
                    <canvas id="monthlyPremiumsGroupedChart"></canvas>
                </div>
            </div>
            
            <!-- Total Profit by Symbol Table -->
            <div class="content-section">
                <div class="section-title">Total Profit by Symbol</div>
                <div class="table-container-scrollable">
                    <table class="financial-table">
                        <thead>
                            <tr>
                                <th>Ticker</th>
                                <th>Total</th>
                                {{range .TableMonthLabels}}
                                <th>{{.}}</th>
                                {{end}}
                            </tr>
                        </thead>
                        <tbody>
                            {{if .TableData}}
                                {{range $row := .TableData}}
                                <tr>
                                    <td><strong><a href="/symbol/{{$row.Ticker}}" class="symbol-link">{{$row.Ticker}}</a></strong></td>
                                    <td><span>${{printf "%.0f" $row.Total}}</span></td>
                                    {{range $yearMonth := $.TableYearMonths}}
                                        {{$amount := index $row.MonthValues $yearMonth}}
                                        <td>{{if $amount}}{{if ne $amount 0.0}}<span>${{printf "%.0f" $amount}}</span>{{else}}$0{{end}}{{else}}$0{{end}}</td>
                                    {{end}}
                                </tr>
                                {{end}}
                            {{else}}
                                <tr>
                                    <td colspan="{{add (len .TableYearMonths) 2}}" style="text-align: center; color: #a0a0a0;">No profit data available</td>
                                </tr>
                            {{end}}
                        </tbody>
                        <tfoot>
                            {{if .TableTotalsByMonth}}
                            <tr class="table-totals-row">
                                <td><strong>Total</strong></td>
                                <td><span><strong>${{printf "%.0f" .GrandTotal}}</strong></span></td>
                                {{range $yearMonth := .TableYearMonths}}
                                    {{$total := index $.TableTotalsByMonth $yearMonth}}
                                    <td><strong>{{if $total}}{{if ne $total 0.0}}<span>${{printf "%.0f" $total}}</span>{{else}}$0{{end}}{{else}}$0{{end}}</strong></td>
                                {{end}}
                            </tr>
                            {{end}}
                        </tfoot>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <!-- Include Shared Symbol Modal -->
    {{template "_symbol_modal.html"}}

    <script>
        // Register the datalabels plugin
        Chart.register(ChartDataLabels);
        
        // Track selected symbol for highlighting
        let selectedSymbol = null;
        
        // Store all chart instances for updating
        const chartInstances = {
            putsTicker: null,
            callsTicker: null,
            capGainsTicker: null,
            dividendsTicker: null,
            monthlyPremiums: null
        };
        
        // Chart colors - original theme palette
        const chartColors = [
            '#3498db',  // Blue
            '#e67e22',  // Orange
            '#27ae60',  // Green
            '#e74c3c',  // Red
            '#f39c12',  // Yellow/Gold
            '#9b59b6',  // Purple
            '#1abc9c',  // Turquoise
            '#34495e',  // Dark Blue-Grey
            '#16a085',  // Dark Turquoise
            '#c0392b',  // Dark Red
            '#d35400',  // Dark Orange
            '#8e44ad'   // Dark Purple
        ];
        
        // Function to get consistent color for a symbol
        function getSymbolColor(symbol, sortedSymbols) {
            const index = sortedSymbols.indexOf(symbol);
            return chartColors[index % chartColors.length];
        }
        
        // Function to sort ticker data by value (largest to smallest)
        function sortTickerData(labels, data) {
            const combined = labels.map((label, index) => ({
                ticker: label,
                amount: data[index]
            }));
            
            // Sort by amount descending (largest to smallest)
            combined.sort((a, b) => b.amount - a.amount);
            
            return {
                labels: combined.map(item => item.ticker),
                data: combined.map(item => item.amount)
            };
        }
        
        // Get actual year-month data from table columns (which have YYYY-MM format)
        const tableYearMonths = [
            {{range $index, $ym := .TableYearMonths}}{{if $index}}, {{end}}"{{$ym}}"{{end}}
        ];
        
        // Use tableYearMonths as the master month list (YYYY-MM format)
        const serverMonthLabels = tableYearMonths;
        
        // Format month labels with year (e.g., "2025-01" -> "Jan 2025")
        const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        const currentMonthLabels = serverMonthLabels.map(ym => {
            const [year, month] = ym.split('-');
            return `${monthNames[parseInt(month) - 1]} ${year}`;
        });

        // Puts - By Month Chart (with cumulative line)
        const putsMonthCtx = document.getElementById('putsMonthChart').getContext('2d');
        
        // Build month-indexed data from PutsData.ByMonth
        const putsMonthMap = new Map([
            {{range $index, $data := .PutsData.ByMonth}}{{if $index}}, {{end}}["{{$data.Month}}", {{$data.Amount}}]{{end}}
        ]);
        // Align with master month labels
        const putsMonthData = serverMonthLabels.map(ym => putsMonthMap.get(ym) || 0);
        
        // Calculate cumulative puts data for individual chart
        let putsIndividualCumulativeData = [];
        let putsIndividualRunningTotal = 0;
        for (let i = 0; i < putsMonthData.length; i++) {
            putsIndividualRunningTotal += putsMonthData[i];
            putsIndividualCumulativeData.push(putsIndividualRunningTotal);
        }
        
        new Chart(putsMonthCtx, {
            type: 'bar',
            data: {
                labels: currentMonthLabels,
                datasets: [{
                    type: 'line',
                    label: 'Cumulative Puts',
                    data: putsIndividualCumulativeData,
                    borderColor: '#FFD700',
                    backgroundColor: 'rgba(255, 215, 0, 0.1)',
                    borderWidth: 3,
                    fill: false,
                    tension: 0.2,
                    yAxisID: 'y1',
                    order: 1
                }, {
                    type: 'bar',
                    label: 'Monthly Puts',
                    data: putsMonthData,
                    backgroundColor: function(context) {
                        const value = context.parsed.y;
                        return value < 0 ? 'rgba(214, 39, 40, 0.6)' : 'rgba(31, 119, 180, 0.6)';
                    },
                    borderColor: function(context) {
                        const value = context.parsed.y;
                        return value < 0 ? '#d62728' : '#1f77b4';
                    },
                    borderWidth: 1,
                    yAxisID: 'y',
                    order: 2
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: { 
                        display: true,
                        position: 'top',
                        labels: {
                            usePointStyle: true
                        }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const label = context.dataset.label || '';
                                return label + ': $' + context.parsed.y.toLocaleString();
                            }
                        }
                    },
                    datalabels: {
                        display: false
                    }
                },
                scales: {
                    y: {
                        type: 'linear',
                        beginAtZero: true,
                        position: 'left',
                        title: {
                            display: true,
                            text: 'Monthly ($)',
                            color: '#1f77b4'
                        },
                        ticks: {
                            callback: function(value) {
                                return '$' + value.toLocaleString();
                            }
                        }
                    },
                    y1: {
                        type: 'linear',
                        beginAtZero: true,
                        position: 'right',
                        title: {
                            display: true,
                            text: 'Cumulative ($)',
                            color: '#FFD700'
                        },
                        ticks: {
                            callback: function(value) {
                                return '$' + value.toLocaleString();
                            }
                        },
                        grid: {
                            drawOnChartArea: false
                        }
                    }
                }
            }
        });

        // Get all ticker data for consistent coloring across both charts
        const putsTickerLabelsUnsorted = [
            {{range $index, $data := .PutsData.ByTicker}}{{if $index}}, {{end}}"{{$data.Ticker}}"{{end}}
        ];
        const putsTickerDataUnsorted = [
            {{range $index, $data := .PutsData.ByTicker}}{{if $index}}, {{end}}{{$data.Amount}}{{end}}
        ];
        const callsTickerLabelsUnsorted = [
            {{range $index, $data := .CallsData.ByTicker}}{{if $index}}, {{end}}"{{$data.Ticker}}"{{end}}
        ];
        const callsTickerDataUnsorted = [
            {{range $index, $data := .CallsData.ByTicker}}{{if $index}}, {{end}}{{$data.Amount}}{{end}}
        ];
        
        // Create unified symbol list for consistent coloring
        const allUniqueSymbols = [...new Set([...putsTickerLabelsUnsorted, ...callsTickerLabelsUnsorted])].sort();
        
        // Puts - By Ticker Chart
        const putsTickerCtx = document.getElementById('putsTickerChart').getContext('2d');
        
        // Sort puts ticker data alphabetically
        const putsSorted = sortTickerData(putsTickerLabelsUnsorted, putsTickerDataUnsorted);
        const putsTickerLabels = putsSorted.labels;
        const putsTickerData = putsSorted.data;
        
        // Get consistent colors for puts symbols
        const putsColors = putsTickerLabels.map(symbol => getSymbolColor(symbol, allUniqueSymbols));
        
        chartInstances.putsTicker = new Chart(putsTickerCtx, {
            type: 'pie',
            data: {
                labels: putsTickerLabels,
                datasets: [{
                    data: putsTickerData,
                    backgroundColor: putsColors,
                    borderWidth: 0.5,
                    borderColor: '#666666'
                }]
            },
            plugins: [ChartDataLabels],
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return context.label + ': $' + context.parsed.toLocaleString();
                            }
                        }
                    },
                    datalabels: {
                        display: true,
                        color: '#e0e0e0',
                        formatter: function(value) {
                            if (value < 500) return '';
                            return '$' + Math.round(value).toLocaleString();
                        },
                        font: {
                            size: 12,
                            weight: 'bold'
                        }
                    }
                }
            }
        });

        // Calls - By Month Chart (with cumulative line)
        const callsMonthCtx = document.getElementById('callsMonthChart').getContext('2d');
        
        // Build month-indexed data from CallsData.ByMonth
        const callsMonthMap = new Map([
            {{range $index, $data := .CallsData.ByMonth}}{{if $index}}, {{end}}["{{$data.Month}}", {{$data.Amount}}]{{end}}
        ]);
        // Align with master month labels
        const callsMonthData = serverMonthLabels.map(ym => callsMonthMap.get(ym) || 0);
        
        // Calculate cumulative calls data for individual chart
        let callsIndividualCumulativeData = [];
        let callsIndividualRunningTotal = 0;
        for (let i = 0; i < callsMonthData.length; i++) {
            callsIndividualRunningTotal += callsMonthData[i];
            callsIndividualCumulativeData.push(callsIndividualRunningTotal);
        }
        
        new Chart(callsMonthCtx, {
            type: 'bar',
            data: {
                labels: currentMonthLabels,
                datasets: [{
                    type: 'line',
                    label: 'Cumulative Calls',
                    data: callsIndividualCumulativeData,
                    borderColor: '#FFD700',
                    backgroundColor: 'rgba(255, 215, 0, 0.1)',
                    borderWidth: 3,
                    fill: false,
                    tension: 0.2,
                    yAxisID: 'y1',
                    order: 1
                }, {
                    type: 'bar',
                    label: 'Monthly Calls',
                    data: callsMonthData,
                    backgroundColor: function(context) {
                        const value = context.parsed.y;
                        return value < 0 ? 'rgba(214, 39, 40, 0.6)' : 'rgba(31, 119, 180, 0.6)';
                    },
                    borderColor: function(context) {
                        const value = context.parsed.y;
                        return value < 0 ? '#d62728' : '#1f77b4';
                    },
                    borderWidth: 1,
                    yAxisID: 'y',
                    order: 2
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: { 
                        display: true,
                        position: 'top',
                        labels: {
                            usePointStyle: true
                        }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const label = context.dataset.label || '';
                                return label + ': $' + context.parsed.y.toLocaleString();
                            }
                        }
                    },
                    datalabels: {
                        display: false
                    }
                },
                scales: {
                    y: {
                        type: 'linear',
                        beginAtZero: true,
                        position: 'left',
                        title: {
                            display: true,
                            text: 'Monthly ($)',
                            color: '#1f77b4'
                        },
                        ticks: {
                            callback: function(value) {
                                return '$' + value.toLocaleString();
                            }
                        }
                    },
                    y1: {
                        type: 'linear',
                        beginAtZero: true,
                        position: 'right',
                        title: {
                            display: true,
                            text: 'Cumulative ($)',
                            color: '#FFD700'
                        },
                        ticks: {
                            callback: function(value) {
                                return '$' + value.toLocaleString();
                            }
                        },
                        grid: {
                            drawOnChartArea: false
                        }
                    }
                }
            }
        });

        // Calls - By Ticker Chart
        const callsTickerCtx = document.getElementById('callsTickerChart').getContext('2d');
        
        // Sort calls ticker data alphabetically
        const callsSorted = sortTickerData(callsTickerLabelsUnsorted, callsTickerDataUnsorted);
        const callsTickerLabels = callsSorted.labels;
        const callsTickerData = callsSorted.data;
        
        // Get consistent colors for calls symbols (using same unified list)
        const callsColors = callsTickerLabels.map(symbol => getSymbolColor(symbol, allUniqueSymbols));
        
        chartInstances.callsTicker = new Chart(callsTickerCtx, {
            type: 'pie',
            data: {
                labels: callsTickerLabels,
                datasets: [{
                    data: callsTickerData,
                    backgroundColor: callsColors,
                    borderWidth: 0.5,
                    borderColor: '#666666'
                }]
            },
            plugins: [ChartDataLabels],
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return context.label + ': $' + context.parsed.toLocaleString();
                            }
                        }
                    },
                    datalabels: {
                        display: true,
                        color: '#e0e0e0',
                        formatter: function(value) {
                            if (value < 500) return '';
                            return '$' + Math.round(value).toLocaleString();
                        },
                        font: {
                            size: 12,
                            weight: 'bold'
                        }
                    }
                }
            }
        });

        // Capital Gains - By Month Chart (with cumulative line)
        const capGainsMonthCtx = document.getElementById('capGainsMonthChart').getContext('2d');
        
        // Build month-indexed data from CapGainsData.ByMonth
        const capGainsMonthMap = new Map([
            {{range $index, $data := .CapGainsData.ByMonth}}{{if $index}}, {{end}}["{{$data.Month}}", {{$data.Amount}}]{{end}}
        ]);
        // Align with master month labels
        const capGainsMonthData = serverMonthLabels.map(ym => capGainsMonthMap.get(ym) || 0);
        
        // Calculate cumulative capital gains data
        let capGainsIndividualCumulativeData = [];
        let capGainsIndividualRunningTotal = 0;
        for (let i = 0; i < capGainsMonthData.length; i++) {
            capGainsIndividualRunningTotal += capGainsMonthData[i];
            capGainsIndividualCumulativeData.push(capGainsIndividualRunningTotal);
        }
        
        new Chart(capGainsMonthCtx, {
            type: 'bar',
            data: {
                labels: currentMonthLabels,
                datasets: [{
                    type: 'line',
                    label: 'Cumulative Cap Gains',
                    data: capGainsIndividualCumulativeData,
                    borderColor: '#FFD700',
                    backgroundColor: 'rgba(255, 215, 0, 0.1)',
                    borderWidth: 3,
                    fill: false,
                    tension: 0.2,
                    yAxisID: 'y1',
                    order: 1
                }, {
                    type: 'bar',
                    label: 'Monthly Cap Gains',
                    data: capGainsMonthData,
                    backgroundColor: function(context) {
                        const value = context.parsed.y;
                        return value < 0 ? 'rgba(214, 39, 40, 0.6)' : 'rgba(31, 119, 180, 0.6)';
                    },
                    borderColor: function(context) {
                        const value = context.parsed.y;
                        return value < 0 ? '#d62728' : '#1f77b4';
                    },
                    borderWidth: 1,
                    yAxisID: 'y',
                    order: 2
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: { 
                        display: true,
                        position: 'top',
                        labels: {
                            usePointStyle: true
                        }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const label = context.dataset.label || '';
                                return label + ': $' + context.parsed.y.toLocaleString();
                            }
                        }
                    },
                    datalabels: {
                        display: false
                    }
                },
                scales: {
                    y: {
                        type: 'linear',
                        beginAtZero: true,
                        position: 'left',
                        title: {
                            display: true,
                            text: 'Monthly ($)',
                            color: '#27ae60'
                        },
                        ticks: {
                            callback: function(value) {
                                return '$' + value.toLocaleString();
                            }
                        }
                    },
                    y1: {
                        type: 'linear',
                        beginAtZero: true,
                        position: 'right',
                        title: {
                            display: true,
                            text: 'Cumulative ($)',
                            color: '#FFD700'
                        },
                        ticks: {
                            callback: function(value) {
                                return '$' + value.toLocaleString();
                            }
                        },
                        grid: {
                            drawOnChartArea: false
                        }
                    }
                }
            }
        });

        // Capital Gains - By Ticker Chart
        const capGainsTickerCtx = document.getElementById('capGainsTickerChart').getContext('2d');
        const capGainsTickerLabelsRaw = [
            {{range $index, $data := .CapGainsData.ByTicker}}{{if $index}}, {{end}}"{{$data.Ticker}}"{{end}}
        ];
        const capGainsTickerDataRaw = [
            {{range $index, $data := .CapGainsData.ByTicker}}{{if $index}}, {{end}}{{$data.Amount}}{{end}}
        ];
        const capGainsTickerSorted = sortTickerData(capGainsTickerLabelsRaw, capGainsTickerDataRaw);
        const capGainsColors = capGainsTickerSorted.labels.map(symbol => getSymbolColor(symbol, allUniqueSymbols));
        chartInstances.capGainsTicker = new Chart(capGainsTickerCtx, {
            type: 'pie',
            data: {
                labels: capGainsTickerSorted.labels,
                datasets: [{
                    data: capGainsTickerSorted.data,
                    backgroundColor: capGainsColors,
                    borderWidth: 0.5,
                    borderColor: '#666666'
                }]
            },
            plugins: [ChartDataLabels],
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return context.label + ': $' + context.parsed.toLocaleString();
                            }
                        }
                    },
                    datalabels: {
                        display: true,
                        color: '#e0e0e0',
                        formatter: function(value) {
                            if (Math.abs(value) < 1000) return '';
                            return '$' + Math.round(value).toLocaleString();
                        },
                        font: {
                            size: 12,
                            weight: 'bold'
                        }
                    }
                }
            }
        });

        // Dividends - By Month Chart (with cumulative line)
        const dividendsMonthCtx = document.getElementById('dividendsMonthChart').getContext('2d');
        
        // Build month-indexed data from DividendsData.ByMonth
        const dividendsMonthMap = new Map([
            {{range $index, $data := .DividendsData.ByMonth}}{{if $index}}, {{end}}["{{$data.Month}}", {{$data.Amount}}]{{end}}
        ]);
        // Align with master month labels
        const dividendsMonthData = serverMonthLabels.map(ym => dividendsMonthMap.get(ym) || 0);
        
        // Calculate cumulative dividends data
        let dividendsIndividualCumulativeData = [];
        let dividendsIndividualRunningTotal = 0;
        for (let i = 0; i < dividendsMonthData.length; i++) {
            dividendsIndividualRunningTotal += dividendsMonthData[i];
            dividendsIndividualCumulativeData.push(dividendsIndividualRunningTotal);
        }
        
        new Chart(dividendsMonthCtx, {
            type: 'bar',
            data: {
                labels: currentMonthLabels,
                datasets: [{
                    type: 'line',
                    label: 'Cumulative Dividends',
                    data: dividendsIndividualCumulativeData,
                    borderColor: '#FFD700',
                    backgroundColor: 'rgba(255, 215, 0, 0.1)',
                    borderWidth: 3,
                    fill: false,
                    tension: 0.2,
                    yAxisID: 'y1',
                    order: 1
                }, {
                    type: 'bar',
                    label: 'Monthly Dividends',
                    data: dividendsMonthData,
                    backgroundColor: function(context) {
                        const value = context.parsed.y;
                        return value < 0 ? 'rgba(214, 39, 40, 0.6)' : 'rgba(31, 119, 180, 0.6)';
                    },
                    borderColor: function(context) {
                        const value = context.parsed.y;
                        return value < 0 ? '#d62728' : '#1f77b4';
                    },
                    borderWidth: 1,
                    yAxisID: 'y',
                    order: 2
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: { 
                        display: true,
                        position: 'top',
                        labels: {
                            usePointStyle: true
                        }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const label = context.dataset.label || '';
                                return label + ': $' + context.parsed.y.toLocaleString();
                            }
                        }
                    },
                    datalabels: {
                        display: false
                    }
                },
                scales: {
                    y: {
                        type: 'linear',
                        beginAtZero: true,
                        position: 'left',
                        title: {
                            display: true,
                            text: 'Monthly ($)',
                            color: '#4CAF50'
                        },
                        ticks: {
                            callback: function(value) {
                                return '$' + value.toLocaleString();
                            }
                        }
                    },
                    y1: {
                        type: 'linear',
                        beginAtZero: true,
                        position: 'right',
                        title: {
                            display: true,
                            text: 'Cumulative ($)',
                            color: '#FFD700'
                        },
                        ticks: {
                            callback: function(value) {
                                return '$' + value.toLocaleString();
                            }
                        },
                        grid: {
                            drawOnChartArea: false
                        }
                    }
                }
            }
        });

        // Dividends - By Ticker Chart
        const dividendsTickerCtx = document.getElementById('dividendsTickerChart').getContext('2d');
        const dividendsTickerLabelsRaw = [
            {{range $index, $data := .DividendsData.ByTicker}}{{if $index}}, {{end}}"{{$data.Ticker}}"{{end}}
        ];
        const dividendsTickerDataRaw = [
            {{range $index, $data := .DividendsData.ByTicker}}{{if $index}}, {{end}}{{$data.Amount}}{{end}}
        ];
        const dividendsTickerSorted = sortTickerData(dividendsTickerLabelsRaw, dividendsTickerDataRaw);
        const dividendsColors = dividendsTickerSorted.labels.map(symbol => getSymbolColor(symbol, allUniqueSymbols));
        chartInstances.dividendsTicker = new Chart(dividendsTickerCtx, {
            type: 'pie',
            data: {
                labels: dividendsTickerSorted.labels,
                datasets: [{
                    data: dividendsTickerSorted.data,
                    backgroundColor: dividendsColors,
                    borderWidth: 0.5,
                    borderColor: '#666666'
                }]
            },
            plugins: [ChartDataLabels],
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return context.label + ': $' + context.parsed.toLocaleString();
                            }
                        }
                    },
                    datalabels: {
                        display: true,
                        color: '#e0e0e0',
                        formatter: function(value) {
                            if (value < 100) return '';
                            return '$' + Math.round(value).toLocaleString();
                        },
                        font: {
                            size: 12,
                            weight: 'bold'
                        }
                    }
                }
            }
        });

        // Added by antamy
        // Gains Over Time chart with Cumulative / Monthly toggle.  A replacement for the original chart
        // Refactored the Totals Panel to pull it out of the code that created that chart

        // Store chart instance globally so we can update it
        let gainsOverTimeChartInstance = null;

        // Update the totals panel with year-to-date values
        function updateTotalsPanelValues(putsTotal, callsTotal, capGainsTotal, dividendsTotal) {
            const grandTotalElement = document.getElementById('grandTotal');
            const totalPutsElement = document.getElementById('totalPuts');
            const totalCallsElement = document.getElementById('totalCalls');
            const totalCapGainsElement = document.getElementById('totalCapGains');
            const totalDividendsElement = document.getElementById('totalDividends');
            
            // Format currency with consistent green coloring
            function formatCurrency(value, element) {
                const formattedValue = '$' + Math.round(Math.abs(value)).toLocaleString();
                if (value < 0) {
                    element.innerHTML = '-' + formattedValue;
                } else {
                    element.innerHTML = formattedValue;
                }
                element.style.color = '#27ae60';
            }
            
            // Calculate grand total
            const grandTotalValue = putsTotal + callsTotal + capGainsTotal + dividendsTotal;
            
            // Update each total
            formatCurrency(grandTotalValue, grandTotalElement);
            formatCurrency(putsTotal, totalPutsElement);
            formatCurrency(callsTotal, totalCallsElement);
            formatCurrency(capGainsTotal, totalCapGainsElement);
            formatCurrency(dividendsTotal, totalDividendsElement);
        }

        // Function to create/update the gains chart
        function createGainsOverTimeChart(viewMode = 'cumulative') {
            const gainsOverTimeCtx = document.getElementById('cumulativeGainsChart').getContext('2d');
            
            // Use the same formatted month labels as the other charts
            const monthLabels = currentMonthLabels;
            
            // Use the same month-aligned data as the individual charts
            const putsMonthlyData = putsMonthData;
            const callsMonthlyData = callsMonthData;
            const capGainsMonthlyData = capGainsMonthData;
            const dividendsMonthlyData = dividendsMonthData;
            
            // Calculate cumulative data for each category
            let putsCumulativeData = [];
            let callsCumulativeData = [];
            let capGainsCumulativeData = [];
            let dividendsCumulativeData = [];
            
            let putsRunningTotal = 0;
            let callsRunningTotal = 0;
            let capGainsRunningTotal = 0;
            let dividendsRunningTotal = 0;
            
            for (let i = 0; i < monthLabels.length; i++) {
                putsRunningTotal += putsMonthlyData[i] || 0;
                callsRunningTotal += callsMonthlyData[i] || 0;
                capGainsRunningTotal += capGainsMonthlyData[i] || 0;
                dividendsRunningTotal += dividendsMonthlyData[i] || 0;
                
                putsCumulativeData.push(putsRunningTotal);
                callsCumulativeData.push(callsRunningTotal);
                capGainsCumulativeData.push(capGainsRunningTotal);
                dividendsCumulativeData.push(dividendsRunningTotal);
            }
            
            // Update totals panel with year-to-date values
            updateTotalsPanelValues(putsRunningTotal, callsRunningTotal, capGainsRunningTotal, dividendsRunningTotal);
            
            // Choose data based on view mode
            let datasets = [];
            let yAxisLabel = '';
            
            if (viewMode === 'cumulative') {
                yAxisLabel = 'Cumulative Gains ($)';
                datasets = [
                    {
                        label: 'Puts',
                        data: putsCumulativeData,
                        backgroundColor: 'rgba(31, 119, 180, 0.8)',
                        borderColor: '#1f77b4',
                        borderWidth: 1
                    },
                    {
                        label: 'Calls',
                        data: callsCumulativeData,
                        backgroundColor: 'rgba(255, 127, 14, 0.8)',
                        borderColor: '#ff7f0e',
                        borderWidth: 1
                    },
                    {
                        label: 'Capital Gains',
                        data: capGainsCumulativeData,
                        backgroundColor: function(context) {
                            const value = context.parsed.y;
                            return value < 0 ? 'rgba(214, 39, 40, 0.8)' : 'rgba(39, 174, 96, 0.8)';
                        },
                        borderColor: function(context) {
                            const value = context.parsed.y;
                            return value < 0 ? '#d62728' : '#27ae60';
                        },
                        borderWidth: 1
                    },
                    {
                        label: 'Dividends',
                        data: dividendsCumulativeData,
                        backgroundColor: 'rgba(255, 215, 0, 0.8)',
                        borderColor: '#FFD700',
                        borderWidth: 1
                    }
                ];
            } else {
                yAxisLabel = 'Monthly Gains ($)';
                datasets = [
                    {
                        label: 'Puts',
                        data: putsMonthlyData,
                        backgroundColor: 'rgba(31, 119, 180, 0.8)',
                        borderColor: '#1f77b4',
                        borderWidth: 1
                    },
                    {
                        label: 'Calls',
                        data: callsMonthlyData,
                        backgroundColor: 'rgba(255, 127, 14, 0.8)',
                        borderColor: '#ff7f0e',
                        borderWidth: 1
                    },
                    {
                        label: 'Capital Gains',
                        data: capGainsMonthlyData,
                        backgroundColor: function(context) {
                            const value = context.parsed.y;
                            return value < 0 ? 'rgba(214, 39, 40, 0.8)' : 'rgba(39, 174, 96, 0.8)';
                        },
                        borderColor: function(context) {
                            const value = context.parsed.y;
                            return value < 0 ? '#d62728' : '#27ae60';
                        },
                        borderWidth: 1
                    },
                    {
                        label: 'Dividends',
                        data: dividendsMonthlyData,
                        backgroundColor: 'rgba(255, 215, 0, 0.8)',
                        borderColor: '#FFD700',
                        borderWidth: 1
                    }
                ];
            }
            
            // Destroy existing chart if it exists
            if (gainsOverTimeChartInstance) {
                gainsOverTimeChartInstance.destroy();
            }
            
            // Create new chart
            gainsOverTimeChartInstance = new Chart(gainsOverTimeCtx, {
                type: 'bar',
                data: {
                    labels: monthLabels,
                    datasets: datasets
                },
                plugins: [ChartDataLabels],
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            stacked: true,
                            title: {
                                display: false
                            },
                            ticks: {
                                color: '#e0e0e0'
                            }
                        },
                        y: {
                            stacked: true,
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: yAxisLabel,
                                color: '#e0e0e0'
                            },
                            ticks: {
                                color: '#e0e0e0',
                                callback: function(value) {
                                    return '$' + value.toLocaleString();
                                }
                            }
                        }
                    },
                    plugins: {
                        legend: { 
                            display: true,
                            position: 'top',
                            labels: {
                                color: '#e0e0e0',
                                usePointStyle: true,
                                padding: 20
                            }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: function(context) {
                                    return context.dataset.label + ': $' + context.parsed.y.toLocaleString();
                                },
                                footer: function(tooltipItems) {
                                    let total = 0;
                                    tooltipItems.forEach(function(tooltipItem) {
                                        total += tooltipItem.parsed.y;
                                    });
                                    return 'Total: $' + total.toLocaleString();
                                }
                            }
                        },
                        datalabels: {
                            display: false
                        }
                    },
                    interaction: {
                        mode: 'index',
                        intersect: false
                    }
                }
            });
        }

        // Initialize chart with cumulative view
        createGainsOverTimeChart('cumulative');

        // Toggle button click handlers
        document.addEventListener('DOMContentLoaded', function() {
            const cumulativeBtn = document.getElementById('cumulativeToggle');
            const monthlyBtn = document.getElementById('monthlyToggle');
            
            if (cumulativeBtn && monthlyBtn) {
                cumulativeBtn.addEventListener('click', function() {
                    // Update button states
                    cumulativeBtn.style.backgroundColor = '#27ae60';
                    cumulativeBtn.style.color = 'white';
                    cumulativeBtn.style.borderColor = '#1e8449';
                    
                    monthlyBtn.style.backgroundColor = '#34495e';
                    monthlyBtn.style.color = '#bdc3c7';
                    monthlyBtn.style.borderColor = '#2c3e50';
                    
                    cumulativeBtn.classList.add('active');
                    monthlyBtn.classList.remove('active');
                    
                    // Update chart
                    createGainsOverTimeChart('cumulative');
                });
                
                monthlyBtn.addEventListener('click', function() {
                    // Update button states
                    monthlyBtn.style.backgroundColor = '#27ae60';
                    monthlyBtn.style.color = 'white';
                    monthlyBtn.style.borderColor = '#1e8449';
                    
                    cumulativeBtn.style.backgroundColor = '#34495e';
                    cumulativeBtn.style.color = '#bdc3c7';
                    cumulativeBtn.style.borderColor = '#2c3e50';
                    
                    monthlyBtn.classList.add('active');
                    cumulativeBtn.classList.remove('active');
                    
                    // Update chart
                    createGainsOverTimeChart('monthly');
                });
            }
        });

        
        // Symbol Modal functionality is handled by shared module
        
        // Apply profit/loss coloring to monthly table
        function applyMonthlyTableColoring() {
            const table = document.querySelector('.financial-table');
            if (!table) return;
            
            // Color all cells with monetary values
            const cells = table.querySelectorAll('td');
            cells.forEach(cell => {
                const text = cell.textContent.trim();
                // Check if it's a monetary value starting with $ and containing a number
                if (text.match(/^\$-?[\d,]+\.\d{2}$/)) {
                    // Extract numeric value
                    const value = parseFloat(text.replace(/[\$,]/g, ''));
                    
                    // Apply coloring: only losses are red, everything else is neutral
                    if (value < 0) {
                        cell.innerHTML = '<span class="negative">' + text + '</span>';
                    } else {
                        // Remove any existing positive class and make neutral
                        cell.classList.remove('positive');
                        if (!cell.innerHTML.includes('<span>') && text !== '$0.00') {
                            cell.innerHTML = '<span>' + text + '</span>';
                        }
                    }
                }
            });
        }
        
        // Apply coloring when page loads
        document.addEventListener('DOMContentLoaded', applyMonthlyTableColoring);
        // Also apply coloring immediately in case DOMContentLoaded already fired
        applyMonthlyTableColoring();

        // Monthly Premiums Grouped Bar Chart using Options Index
        function createMonthlyPremiumsGroupedChart() {
            const ctx = document.getElementById('monthlyPremiumsGroupedChart');
            if (!ctx) return;

            // Get options index from template data
            let optionsIndex;
            try {
                optionsIndex = {{.OptionsIndexJSON}};
                console.log('Monthly: Options index loaded:', optionsIndex);
            } catch (e) {
                console.error('Monthly: Failed to parse options index:', e);
                return;
            }

            if (!optionsIndex || !optionsIndex.id) {
                console.warn('Monthly: No options data available');
                return;
            }

            // Get all options as array
            const allOptions = Object.values(optionsIndex.id);
            
            // Extract distinct yyyy-mm dates from options and sort them
            const yearMonthSet = new Set();
            allOptions.forEach(option => {
                const dateStr = option.opened;
                const yearMonth = dateStr.substring(0, 7); // Extract "yyyy-mm"
                yearMonthSet.add(yearMonth);
            });
            
            // Sort year-months ascending
            const sortedYearMonths = Array.from(yearMonthSet).sort();
            
            // Create display labels (e.g., "2025-01" -> "Jan 2025")
            const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            const monthLabels = sortedYearMonths.map(ym => {
                const [year, month] = ym.split('-');
                return `${monthNames[parseInt(month) - 1]} ${year}`;
            });
            
            // Process options by year-month and group by symbol and open/closed status
            const monthlyData = {};
            
            allOptions.forEach(option => {
                // Use opened date for premium realization (when premium was received)
                // Parse yyyy-mm directly from ISO date string
                const dateStr = option.opened;
                const yearMonth = dateStr.substring(0, 7); // Extract "yyyy-mm"
                
                if (!monthlyData[yearMonth]) {
                    monthlyData[yearMonth] = {};
                }
                
                if (!monthlyData[yearMonth][option.symbol]) {
                    monthlyData[yearMonth][option.symbol] = { open: 0, closed: 0 };
                }
                
                // Calculate total profit for this option (same logic as Go backend)
                let totalProfit = option.premium * option.contracts * 100;
                if (option.closed && option.exit_price) {
                    totalProfit -= option.exit_price * option.contracts * 100;
                }
                if (option.commission) {
                    totalProfit -= option.commission;
                }
                
                // Group by open/closed status
                if (option.closed) {
                    monthlyData[yearMonth][option.symbol].closed += totalProfit;
                } else {
                    monthlyData[yearMonth][option.symbol].open += totalProfit;
                }
            });

            // Use dynamic month labels based on actual data
            const currentMonthLabels = monthLabels;
            
            // Extract all symbols that appear in the data and calculate total profit for sorting
            const symbolTotals = {};
            Object.values(monthlyData).forEach(monthData => {
                Object.keys(monthData).forEach(symbol => {
                    if (!symbolTotals[symbol]) {
                        symbolTotals[symbol] = 0;
                    }
                    symbolTotals[symbol] += monthData[symbol].closed + monthData[symbol].open;
                });
            });
            
            // Sort symbols by total profit descending (largest to smallest)
            const sortedSymbols = Object.keys(symbolTotals).sort((a, b) => symbolTotals[b] - symbolTotals[a]);
            
            // Build datasets - one stack for Open positions, one stack for Closed positions
            // Within each stack, aggregate all symbols
            const datasets = [];
            
            // Calculate max total for suggestedMax (to ensure labels don't get cut off)
            let maxTotal = 0;
            sortedYearMonths.forEach(ym => {
                let monthTotal = 0;
                sortedSymbols.forEach(symbol => {
                    if (monthlyData[ym] && monthlyData[ym][symbol]) {
                        monthTotal += monthlyData[ym][symbol].closed + monthlyData[ym][symbol].open;
                    }
                });
                if (monthTotal > maxTotal) {
                    maxTotal = monthTotal;
                }
            });
            const suggestedMax = maxTotal * 1.1; // Add 10% headroom
            
            sortedSymbols.forEach((symbol, index) => {
                const baseColor = getSymbolColor(symbol, allUniqueSymbols);
                
                // Dataset for this symbol's closed positions (will be stacked together)
                const closedData = sortedYearMonths.map(ym => {
                    return monthlyData[ym] && monthlyData[ym][symbol] ? monthlyData[ym][symbol].closed : 0;
                });
                
                datasets.push({
                    label: symbol + ' (Closed)',
                    data: closedData,
                    backgroundColor: baseColor,
                    borderColor: baseColor,
                    borderWidth: 1,
                    stack: 'closed', // All closed positions in one stack
                    order: 1 // Closed stack first
                });
                
                // Dataset for this symbol's open positions (will be stacked together)
                const openData = sortedYearMonths.map(ym => {
                    return monthlyData[ym] && monthlyData[ym][symbol] ? monthlyData[ym][symbol].open : 0;
                });
                
                // Use same color but with transparency to distinguish from closed
                const openColor = baseColor + '80'; // Add alpha for transparency
                
                datasets.push({
                    label: symbol + ' (Open)',
                    data: openData,
                    backgroundColor: openColor,
                    borderColor: baseColor,
                    borderWidth: 1,
                    stack: 'open', // All open positions in one stack
                    order: 2 // Open stack second
                });
            });

            chartInstances.monthlyPremiums = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: currentMonthLabels,
                    datasets: datasets
                },
                plugins: [ChartDataLabels],
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    scales: {
                        x: {
                            grid: {
                                color: '#404040'
                            },
                            ticks: {
                                color: '#e0e0e0'
                            }
                        },
                        y: {
                            beginAtZero: true,
                            suggestedMax: suggestedMax,
                            grid: {
                                color: '#404040'
                            },
                            ticks: {
                                color: '#e0e0e0',
                                callback: function(value) {
                                    return '$' + Math.round(value).toLocaleString();
                                }
                            },
                            title: {
                                display: true,
                                text: 'Monthly Premiums ($)',
                                color: '#e0e0e0'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            backgroundColor: 'rgba(20, 20, 20, 0.95)',
                            titleColor: '#ffffff',
                            bodyColor: '#ffffff',
                            borderColor: '#007acc',
                            borderWidth: 2,
                            cornerRadius: 8,
                            padding: 16,
                            displayColors: false,
                            titleFont: {
                                size: 16,
                                weight: 'bold',
                                family: 'monospace'
                            },
                            bodyFont: {
                                size: 13,
                                family: 'monospace'
                            },
                            caretSize: 8,
                            position: 'nearest',
                            enabled: false, // Disable default tooltip
                            external: function(context) {
                                // Custom tooltip implementation for table layout
                                const {chart, tooltip} = context;
                                
                                // Remove existing custom tooltip
                                let tooltipEl = document.getElementById('chartjs-tooltip');
                                if (!tooltipEl) {
                                    tooltipEl = document.createElement('div');
                                    tooltipEl.id = 'chartjs-tooltip';
                                    document.body.appendChild(tooltipEl);
                                }
                                
                                // Hide tooltip if no data
                                if (tooltip.opacity === 0) {
                                    tooltipEl.style.opacity = 0;
                                    tooltipEl.style.visibility = 'hidden';
                                    return;
                                }
                                
                                if (tooltip.body && tooltip.dataPoints && tooltip.dataPoints.length > 0) {
                                    const monthIndex = tooltip.dataPoints[0].dataIndex;
                                    const monthLabel = currentMonthLabels[monthIndex];
                                    const yearMonth = sortedYearMonths[monthIndex];
                                    
                                    if (!yearMonth || !monthlyData[yearMonth]) {
                                        tooltipEl.style.opacity = 0;
                                        return;
                                    }
                                    
                                    // Calculate comprehensive summary for the month
                                    let openTotal = 0;
                                    let closedTotal = 0;
                                    const symbolSummary = {};
                                    
                                    sortedSymbols.forEach(symbol => {
                                        const monthData = monthlyData[yearMonth] && monthlyData[yearMonth][symbol];
                                        if (monthData) {
                                            const symbolOpen = monthData.open || 0;
                                            const symbolClosed = monthData.closed || 0;
                                            const symbolTotal = symbolOpen + symbolClosed;
                                            
                                            // Include all symbols with non-zero values (positive or negative)
                                            if (symbolTotal !== 0) {
                                                symbolSummary[symbol] = {
                                                    open: symbolOpen,
                                                    closed: symbolClosed,
                                                    total: symbolTotal
                                                };
                                                
                                                openTotal += symbolOpen;
                                                closedTotal += symbolClosed;
                                            }
                                        }
                                    });
                                    
                                    const grandTotal = openTotal + closedTotal;
                                    const symbolKeys = Object.keys(symbolSummary).sort();
                                    
                                    // Build HTML table content
                                    let html = `
                                        <div style="
                                            background: rgba(20, 20, 20, 0.95);
                                            border: 2px solid #007acc;
                                            border-radius: 8px;
                                            padding: 16px;
                                            font-family: monospace;
                                            color: #ffffff;
                                            width: 600px;
                                            max-width: 90vw;
                                            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                                        ">
                                            <div style="
                                                font-size: 16px;
                                                font-weight: bold;
                                                text-align: center;
                                                margin-bottom: 16px;
                                                padding-bottom: 8px;
                                                border-bottom: 1px solid #007acc;
                                                color: #007acc;
                                            ">
                                                ${monthLabel} Monthly Premiums Summary
                                            </div>
                                            
                                            <!-- Summary Totals Table -->
                                            <table style="
                                                width: 100%;
                                                margin-bottom: 16px;
                                                border-collapse: collapse;
                                                background: rgba(0, 122, 204, 0.1);
                                                border-radius: 4px;
                                            ">
                                                <tr>
                                                    <td style="padding: 8px 12px; font-weight: bold; width: 25%;">TOTAL MONTH:</td>
                                                    <td style="padding: 8px 12px; font-weight: bold; color: ${grandTotal < 0 ? '#e74c3c' : '#27ae60'};">${grandTotal < 0 ? '-' : ''}$${Math.round(Math.abs(grandTotal)).toLocaleString()}</td>
                                                    <td style="padding: 8px 12px; font-weight: bold; width: 25%;">CLOSED:</td>
                                                    <td style="padding: 8px 12px; font-weight: bold; color: ${closedTotal < 0 ? '#e74c3c' : '#ffffff'};">${closedTotal < 0 ? '-' : ''}$${Math.round(Math.abs(closedTotal)).toLocaleString()}</td>
                                                </tr>
                                                <tr>
                                                    <td style="padding: 8px 12px; font-weight: bold;">SYMBOLS:</td>
                                                    <td style="padding: 8px 12px; font-weight: bold; color: #ffffff;">${symbolKeys.length}</td>
                                                    <td style="padding: 8px 12px; font-weight: bold;">OPEN:</td>
                                                    <td style="padding: 8px 12px; font-weight: bold; color: ${openTotal < 0 ? '#e74c3c' : '#ffffff'};">${openTotal < 0 ? '-' : ''}$${Math.round(Math.abs(openTotal)).toLocaleString()}</td>
                                                </tr>
                                            </table>
                                            
                                            <!-- Detailed Breakdown Table -->
                                            <div style="
                                                font-size: 14px;
                                                font-weight: bold;
                                                margin-bottom: 8px;
                                                color: #007acc;
                                            ">BREAKDOWN BY SYMBOL</div>
                                            
                                            <table style="
                                                width: 100%;
                                                border-collapse: collapse;
                                                font-size: 12px;
                                                background: rgba(255, 255, 255, 0.05);
                                            ">
                                                <thead>
                                                    <tr style="background: rgba(0, 122, 204, 0.3);">
                                                        <th style="padding: 6px 8px; text-align: left; border-bottom: 1px solid #404040;">SYMBOL</th>
                                                        <th style="padding: 6px 8px; text-align: right; border-bottom: 1px solid #404040;">TOTAL</th>
                                                        <th style="padding: 6px 8px; text-align: right; border-bottom: 1px solid #404040;">CLOSED</th>
                                                        <th style="padding: 6px 8px; text-align: right; border-bottom: 1px solid #404040;">OPEN</th>
                                                        <th style="padding: 6px 8px; text-align: right; border-bottom: 1px solid #404040;">% OF MONTH</th>
                                                    </tr>
                                                </thead>
                                                <tbody>`;
                                    
                                    symbolKeys.forEach((symbol, index) => {
                                        const data = symbolSummary[symbol];
                                        const percentage = grandTotal !== 0 ? ((Math.abs(data.total) / Math.abs(grandTotal)) * 100).toFixed(1) : '0.0';
                                        const rowBg = index % 2 === 0 ? 'rgba(255, 255, 255, 0.02)' : 'transparent';
                                        
                                        // Color coding for positive/negative values
                                        const totalColor = data.total < 0 ? '#e74c3c' : '#27ae60';
                                        const closedColor = data.closed < 0 ? '#e74c3c' : '#ffffff';
                                        const openColor = data.open < 0 ? '#e74c3c' : '#ffffff';
                                        
                                        // Format values properly with negative signs
                                        const formatValue = (value) => {
                                            const absValue = Math.abs(value);
                                            return value < 0 ? `-$${Math.round(absValue).toLocaleString()}` : `$${Math.round(absValue).toLocaleString()}`;
                                        };
                                        
                                        html += `
                                            <tr style="background: ${rowBg};">
                                                <td style="padding: 4px 8px; font-weight: bold;">${symbol}</td>
                                                <td style="padding: 4px 8px; text-align: right; font-weight: bold; color: ${totalColor};">${formatValue(data.total)}</td>
                                                <td style="padding: 4px 8px; text-align: right; color: ${closedColor};">${formatValue(data.closed)}</td>
                                                <td style="padding: 4px 8px; text-align: right; color: ${openColor};">${formatValue(data.open)}</td>
                                                <td style="padding: 4px 8px; text-align: right; color: #ffa500;">${percentage}%</td>
                                            </tr>`;
                                    });
                                    
                                    html += `
                                                </tbody>
                                            </table>
                                        </div>`;
                                    
                                    tooltipEl.innerHTML = html;
                                }
                                
                                // Position tooltip with viewport boundary detection
                                const canvasRect = chart.canvas.getBoundingClientRect();
                                
                                // Calculate desired position (centered horizontally, 50px above cursor)
                                let leftPos = canvasRect.left + window.scrollX + tooltip.caretX - 300;
                                let topPos = canvasRect.top + window.scrollY + tooltip.caretY - 50;
                                
                                // Get tooltip dimensions (assume 600px width from inline style)
                                const tooltipWidth = 600;
                                const tooltipHeight = 400; // Approximate height
                                
                                // Ensure tooltip stays within horizontal viewport bounds
                                const viewportWidth = window.innerWidth;
                                const minLeft = 10; // 10px margin from left edge
                                const maxLeft = viewportWidth - tooltipWidth - 10; // 10px margin from right edge
                                
                                if (leftPos < minLeft) {
                                    leftPos = minLeft;
                                } else if (leftPos > maxLeft) {
                                    leftPos = maxLeft;
                                }
                                
                                // Ensure tooltip stays within vertical viewport bounds
                                const viewportHeight = window.innerHeight;
                                const minTop = 10; // 10px margin from top edge
                                const maxTop = viewportHeight - tooltipHeight - 10; // 10px margin from bottom edge
                                
                                if (topPos < minTop) {
                                    topPos = minTop;
                                } else if (topPos > maxTop) {
                                    topPos = maxTop;
                                }
                                
                                tooltipEl.style.opacity = 1;
                                tooltipEl.style.visibility = 'visible';
                                tooltipEl.style.position = 'absolute';
                                tooltipEl.style.left = leftPos + 'px';
                                tooltipEl.style.top = topPos + 'px';
                                tooltipEl.style.pointerEvents = 'none';
                                tooltipEl.style.zIndex = '9999';
                            }
                        },
                        datalabels: {
                            display: false // Disable for grouped bars to avoid clutter
                        }
                    }
                },
                plugins: [{
                    id: 'stackTotals',
                    afterDatasetsDraw: function(chart) {
                        const ctx = chart.ctx;
                        ctx.save();
                        
                        // Set font for stack totals
                        ctx.font = 'bold 12px Arial';
                        ctx.fillStyle = '#27ae60';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'bottom';
                        
                        // Calculate totals for each month and stack
                        chart.data.labels.forEach((label, monthIndex) => {
                            const yearMonth = sortedYearMonths[monthIndex];
                            
                            // Calculate totals for this month
                            let openTotal = 0;
                            let closedTotal = 0;
                            
                            sortedSymbols.forEach(symbol => {
                                const monthData = monthlyData[yearMonth] && monthlyData[yearMonth][symbol];
                                if (monthData) {
                                    openTotal += monthData.open;
                                    closedTotal += monthData.closed;
                                }
                            });
                            
                            // Find the top of each stack
                            let openStackTop = chart.chartArea.bottom;
                            let closedStackTop = chart.chartArea.bottom;
                            let openStackX = null;
                            let closedStackX = null;
                            
                            // Get the positions from the chart metadata
                            chart.data.datasets.forEach((dataset, datasetIndex) => {
                                const meta = chart.getDatasetMeta(datasetIndex);
                                if (meta.data[monthIndex] && dataset.data[monthIndex] > 0) {
                                    const bar = meta.data[monthIndex];
                                    
                                    if (dataset.stack === 'open') {
                                        if (bar.y < openStackTop) {
                                            openStackTop = bar.y;
                                            openStackX = bar.x;
                                        }
                                    } else if (dataset.stack === 'closed') {
                                        if (bar.y < closedStackTop) {
                                            closedStackTop = bar.y;
                                            closedStackX = bar.x;
                                        }
                                    }
                                }
                            });
                            
                            // Draw the totals above each stack
                            if (closedTotal > 0 && closedStackX !== null) {
                                const formattedClosedTotal = '$' + Math.round(closedTotal).toLocaleString();
                                ctx.fillText(formattedClosedTotal, closedStackX, closedStackTop - 5);
                            }
                            
                            if (openTotal > 0 && openStackX !== null) {
                                const formattedOpenTotal = '$' + Math.round(openTotal).toLocaleString();
                                ctx.fillText(formattedOpenTotal, openStackX, openStackTop - 5);
                            }
                        });
                        
                        ctx.restore();
                    }
                }]
            });
        }

        // Create unified symbol legend
        function createSymbolLegend() {
            const legendContainer = document.getElementById('symbolLegend');
            if (!legendContainer) return;
            
            let html = '';
            
            allUniqueSymbols.forEach(symbol => {
                const color = getSymbolColor(symbol, allUniqueSymbols);
                html += `
                    <div class="legend-item" data-symbol="${symbol}" style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 4px; border-radius: 4px; transition: background-color 0.2s;">
                        <div style="width: 18px; height: 18px; background-color: ${color}; border: 1px solid #ccc; border-radius: 3px; flex-shrink: 0;"></div>
                        <span style="color: #e0e0e0; font-size: 14px; font-weight: 500;">${symbol}</span>
                    </div>
                `;
            });
            
            legendContainer.innerHTML = html;
            
            // Add click handlers to legend items
            document.querySelectorAll('.legend-item').forEach(item => {
                item.addEventListener('click', function() {
                    const symbol = this.getAttribute('data-symbol');
                    toggleSymbolHighlight(symbol);
                });
                
                item.addEventListener('mouseenter', function() {
                    this.style.backgroundColor = 'rgba(255, 255, 255, 0.1)';
                });
                
                item.addEventListener('mouseleave', function() {
                    this.style.backgroundColor = 'transparent';
                });
            });
        }
        
        // Toggle symbol highlighting across all charts
        function toggleSymbolHighlight(symbol) {
            if (selectedSymbol === symbol) {
                // Deselect
                selectedSymbol = null;
            } else {
                // Select new symbol
                selectedSymbol = symbol;
            }
            
            // Update legend highlighting
            document.querySelectorAll('.legend-item').forEach(item => {
                if (item.getAttribute('data-symbol') === selectedSymbol) {
                    item.style.backgroundColor = 'rgba(39, 174, 96, 0.3)';
                    item.style.borderLeft = '3px solid #27ae60';
                    item.style.paddingLeft = '8px';
                } else {
                    item.style.backgroundColor = 'transparent';
                    item.style.borderLeft = 'none';
                    item.style.paddingLeft = '4px';
                }
            });
            
            // Update all charts
            updateChartHighlights();
        }
        
        // Update all charts with highlighting
        function updateChartHighlights() {
            // Update pie charts
            [chartInstances.putsTicker, chartInstances.callsTicker, 
             chartInstances.capGainsTicker, chartInstances.dividendsTicker].forEach(chart => {
                if (chart) {
                    chart.data.datasets[0].borderWidth = chart.data.labels.map(label => 
                        label === selectedSymbol ? 3 : 0.5
                    );
                    chart.data.datasets[0].borderColor = chart.data.labels.map(label => 
                        label === selectedSymbol ? '#ffffff' : '#666666'
                    );
                    chart.update();
                }
            });
            
            // Update monthly premiums stacked bar chart
            if (chartInstances.monthlyPremiums) {
                chartInstances.monthlyPremiums.data.datasets.forEach(dataset => {
                    const symbol = dataset.label.replace(' (Closed)', '').replace(' (Open)', '');
                    if (symbol === selectedSymbol) {
                        dataset.borderWidth = 3;
                        dataset.borderColor = '#ffffff';
                    } else {
                        dataset.borderWidth = 1;
                        dataset.borderColor = dataset.backgroundColor;
                    }
                });
                chartInstances.monthlyPremiums.update();
            }
        }
        
        // Create the grouped bar chart when page loads
        document.addEventListener('DOMContentLoaded', function() {
            createMonthlyPremiumsGroupedChart();
            createSymbolLegend();
        });
    </script>
    <script src="/static/js/navigation.js"></script>
    <script src="/static/js/symbol-modal.js"></script>
    <script>
        // Apply profit/loss coloring and currency formatting to monthly table
        function applyMonthlyTableFormatting() {
            const table = document.querySelector('.financial-table');
            if (!table) return;
            
            // Process all rows in tbody and tfoot
            const rows = table.querySelectorAll('tbody tr, tfoot tr');
            rows.forEach(row => {
                const cells = row.querySelectorAll('td');
                cells.forEach((cell, columnIndex) => {
                    const text = cell.textContent.trim();
                    
                    // Skip the first column (Ticker/Symbol)
                    if (columnIndex === 0) return;
                    
                    // Check if it's a monetary value (with or without decimal places)
                    if (text.match(/^\$-?[\d,]*\.?\d*$/)) {
                        // Extract numeric value
                        const value = parseFloat(text.replace(/[\$,]/g, ''));
                        
                        // Skip if it's not a valid number
                        if (isNaN(value)) return;
                        
                        // Format as whole dollars with comma separators
                        const formattedValue = '$' + Math.round(Math.abs(value)).toLocaleString();
                        
                        // Apply profit/loss coloring to all monetary values
                        if (value < 0) {
                            cell.innerHTML = '<span class="negative">-' + formattedValue + '</span>';
                        } else if (value > 0) {
                            cell.innerHTML = '<span class="positive">' + formattedValue + '</span>';
                        } else {
                            cell.innerHTML = formattedValue;
                        }
                    }
                });
            });
        }

        // Apply table formatting when page loads
        document.addEventListener('DOMContentLoaded', function() {
            applyMonthlyTableFormatting();
        });
    </script>
    <script src="/static/js/table-sort.js"></script>

</body>
</html>